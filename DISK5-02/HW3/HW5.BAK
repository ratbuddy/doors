COMMENT   *
          Well, this program will print out the answer to a postscipt
          equation consisting of +'s and -'s.  It will also tell
          the user if his/her program does NOT conform to a
          logical postscript function.
          *
EXTRN  PUTDEC:FAR
s_stack segment stack
        db 256 dup (0)
s_stack ends

     LF EQU 10
     CR EQU 13
DOSCALL EQU 21H

_DATA SEGMENT
     NEWLIN DB LF,CR,'$'
     HEADER DB LF,LF,CR,'Postfix Evulation by Eddie Gaul$'
     PROMPT DB LF,CR,'PLEASE TYPE A POSTFIX EQUATION:  $'
     ANSWER DB LF,CR,'The Answer is:  $'
     BADCHAR DB LF,CR,'Invalid Character, Please Try Again$'
     MANYNUM DB LF,CR,'Not Enough Operators, Too many digits$'
     MANYOPT DB LF,CR,'Too many Operators, too few digits!$'
     INPUTBF DB 80
     COUNT   DB ?
     INPUTST DB 81 DUP (?)
     NUMBER  DW 0
_data ends

_text segment
   assume cs:_text, ds:_data, ss:S_Stack
   start:
   MOV AX,_DATA
   MOV DS,AX
   MOV AH,09
   LEA DX,HEADER
   INT DOSCALL
RESTART:
   LEA DX,PROMPT
   INT DOSCALL
   LEA DX,NEWLIN
   INT DOSCALL

   MOV AH,0AH
   MOV DX,OFFSET INPUTBF           ; GET INPUT
   INT 21H
   CMP COUNT,1
   JB  QUIT
   SUB CX,CX
   MOV SI,OFFSET INPUTST

GO_AHEAD:

           CMP BYTE PTR [SI],32
           JE  COME_BACK
           CMP BYTE PTR [SI],'+'
           JE  ADD_AN_ADD
           CMP BYTE PTR [SI],'-'
           JE  NEGATIVES
           CMP BYTE PTR [SI],48
           JB  BAD_CHAR
           CMP BYTE PTR [SI],57
           JA  BAD_CHAR
           CALL NUMBERS
           PUSH DX                     ; SAVES RESULTS FROM NUMBERS
COME_BACK:
      INC SI
      INC CL
      CMP CL,COUNT
      JS GO_AHEAD
POP AX                     ; FINAL result
MOV BH,0
CALL PUTDEC
JMP QUIT                ; FOR TESTING PURPOSES

BAD_CHAR:
   LEA DX,BADCHAR
   MOV AH,09
   INT DOSCALL
   JMP QUIT
ADD_AN_ADD:             ; DO WORK
   POP AX
   POP DX
   ADD AX,DX            ; RESULT IN AX
   PUSH AX              ; SAVES WORK, NO CHECK WHATSOEVER!
   JMP COME_BACK
NEGATIVES:              ; DO WORK
   POP DX
   POP AX
   SUB AX,DX
   PUSH AX              ; DOESN'T CHECK FOR NEGATIVES!!!!!
   JMP COME_BACK

QUIT: MOV AX, 4C00H
      INT 21H

NUMBERS PROC NEAR
  MOV AH,09
  LEA DX,NEWLIN
  INT DOSCALL                   ; PRINT SOME CAR. RA'S
  SUB DX,DX                     ; DX=0
  SUB BX,BX                     ; BX=0
  LOOPTOP:
   MOV BL,BYTE PTR [SI]
   SUB BL,48                    ; GET INT VALUE
   ADD DX,BX                    ; ADD IT TO WHATEVER MAY BE IN DX
   INC SI                       ; INC SI
   INC CL                       ; IN COUNTER SO ITS COOL WHEN WE GET BACK
   CMP BYTE PTR [SI],48         ; CHECK TO SEE IF LOWER THAN '0'
   JB LOOPEND
   CMP BYTE PTR [SI],57         ; CHECK TO SEE IF HIGHER THAN A '9'
   JA LOOPEND
   MOV AX,DX                    ; STORE DX INTO AX
   MOV BX,10                    ;
   IMUL BX                      ; INTEGER MULTIPLY AX BY 10
   MOV DX,AX                    ; PUT NEW VALUE INTO DX
  JMP LOOPTOP
LOOPEND:
DEC CL                          ;  SET SI AND CL BACK ONE
DEC SI                          ; CUZ WE WANT TO ACCOUNT FOR IT WHEN WE GET
RET
NUMBERS ENDP

_TEXT ENDS
END START



